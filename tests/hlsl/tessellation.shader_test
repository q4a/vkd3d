[require]
shader model >= 5.0

[vertex shader]
struct data
{
    float4 position : SV_Position;
    float r : RED;
    float g : GREEN;
    float b : BLUE;
};

void main(uint id : SV_VertexID, out data output)
{
    float2 coords = float2((id << 1) & 2, id & 2);
    output.position = float4(coords * float2(2, -2) + float2(-1, 1), 0, 1);
    output.r = 0.0;
    output.g = 1.0;
    output.b = 0.0;
}

[hull shader]
struct data
{
    float4 position : SV_Position;
    float r : RED;
    float g : GREEN;
    float b : BLUE;
};

struct patch_constant_data
{
    float edges[3] : SV_TessFactor;
    float inside : SV_InsideTessFactor;
};

void patch_constant(InputPatch<data, 3> input, out patch_constant_data output)
{
    output.edges[0] = output.edges[1] = output.edges[2] = 1.0f;
    output.inside = 1.0f;
}

    [domain("tri")]
    [outputcontrolpoints(3)]
    [partitioning("integer")]
    [outputtopology("triangle_cw")]
    [patchconstantfunc("patch_constant")]
data main(InputPatch<data, 3> input, uint i : SV_OutputControlPointID)
{
    return input[i];
}

[domain shader]
struct data
{
    float4 position : SV_Position;
    float r : RED;
    float g : GREEN;
    float b : BLUE;
};

struct patch_constant_data
{
    float edges[3] : SV_TessFactor;
    float inside : SV_InsideTessFactor;
};

    [domain("tri")]
void main(patch_constant_data input,
        float3 tess_coord : SV_DomainLocation,
        const OutputPatch<data, 3> patch,
        out data output)
{
    output.position = tess_coord.x * patch[0].position
            + tess_coord.y * patch[1].position
            + tess_coord.z * patch[2].position;
    output.r = tess_coord.x * patch[0].r + tess_coord.y * patch[1].r + tess_coord.z * patch[2].r;
    output.g = tess_coord.x * patch[0].g + tess_coord.y * patch[1].g + tess_coord.z * patch[2].g;
    output.b = tess_coord.x * patch[0].b + tess_coord.y * patch[1].b + tess_coord.z * patch[2].b;
}

[pixel shader]
struct data
{
    float4 position : SV_Position;
    float r : RED;
    float g : GREEN;
    float b : BLUE;
};

float4 main(data input) : sv_target
{
    return float4(input.r, input.g, input.b, 1.0);
}

[test]
% llvmpipe currently segfaults due to a bug during shader compilation in the driver.
if(!llvmpipe) todo(glsl | msl | mvk & vulkan) draw 3 control point patch list 3
if(!llvmpipe) todo(mvk) probe (0, 0, 640, 480) rgba(0.0, 1.0, 0.0, 1.0)

% Passthrough hull shader control point function.
[hull shader todo]
struct data
{
    float4 position : SV_Position;
    float r : RED;
    float g : GREEN;
    float b : BLUE;
};

struct patch_constant_data
{
    float edges[3] : SV_TessFactor;
    float inside : SV_InsideTessFactor;
};

void patch_constant(InputPatch<data, 3> input, out patch_constant_data output)
{
    output.edges[0] = output.edges[1] = output.edges[2] = 1.0f;
    output.inside = 1.0f;
}

    [domain("tri")]
    [outputcontrolpoints(3)]
    [partitioning("integer")]
    [outputtopology("triangle_cw")]
    [patchconstantfunc("patch_constant")]
void main(InputPatch<data, 3> input)
{
}

[test]
if(!llvmpipe) todo(sm<6) draw 3 control point patch list 3
if(!llvmpipe) todo(mvk) probe (0, 0, 640, 480) rgba(0.0, 1.0, 0.0, 1.0)

[require]
shader model >= 5.0
shader model < 5.1

[hull shader dxbc-tpf-hex]
% As above, but with some DCL_INDEXRANGE instructions that skip a signature
% element (i.e., it has "dcl_indexrange o0.z 3" at some point, but o1.z does
% not exist). This must be kept in compiled form rather than source code
% because we want to test a specific quirk of the code generated by the native
% d3dcompiler. It should be converted to assembly as soon as that's available,
% though.

% struct data
% {
%     float4 position : SV_Position;
%     float r : RED;
%     float g : GREEN;
%     float b : BLUE;
% };
%
% struct patch_constant_data
% {
%     float edges[3] : SV_TessFactor;
%     float inside : SV_InsideTessFactor;
%     float2 x : X;
%     float1 y : Y;
%     float2 z : Z;
% };
%
% void patch_constant(InputPatch<data, 3> input, out patch_constant_data output)
% {
%     output.edges[0] = output.edges[1] = output.edges[2] = 1.0f;
%     output.inside = 1.0f;
%     output.x = 0.0f;
%     output.y = 0.0f;
%     output.z = 0.0f;
% }
%
%     [domain("tri")]
%     [outputcontrolpoints(3)]
%     [partitioning("integer")]
%     [outputtopology("triangle_cw")]
%     [patchconstantfunc("patch_constant")]
% data main(InputPatch<data, 3> input, uint i : SV_OutputControlPointID)
% {
%     return input[i];
% }

% hs_5_0
% hs_decls
% dcl_input_control_point_count 3
% dcl_output_control_point_count 3
% dcl_tessellator_domain domain_tri
% dcl_tessellator_partitioning partitioning_integer
% dcl_tessellator_output_primitive output_triangle_cw
% dcl_globalFlags refactoringAllowed
% hs_fork_phase
% dcl_hs_fork_phase_instance_count 3
% dcl_input vForkInstanceID
% dcl_output_siv o0.x, finalTriUeq0EdgeTessFactor
% dcl_output_siv o1.x, finalTriVeq0EdgeTessFactor
% dcl_output_siv o2.x, finalTriWeq0EdgeTessFactor
% dcl_temps 1
% dcl_indexrange o0.x 3
% mov r0.x, vForkInstanceID.x
% mov o[r0.x + 0].x, l(1.000000)
% ret
% hs_fork_phase
% dcl_output_siv o3.x, finalTriInsideTessFactor
% mov o3.x, l(1.000000)
% ret
% hs_fork_phase
% dcl_hs_fork_phase_instance_count 3
% dcl_input vForkInstanceID
% dcl_output o0.y
% dcl_output o1.y
% dcl_output o2.y
% dcl_temps 1
% dcl_indexrange o0.y 3
% mov r0.x, vForkInstanceID.x
% mov o[r0.x + 0].y, l(0)
% ret
% hs_fork_phase
% dcl_hs_fork_phase_instance_count 2
% dcl_input vForkInstanceID
% dcl_output o0.z
% dcl_output o2.z
% dcl_temps 1
% dcl_indexrange o0.z 3
% ult r0.x, vForkInstanceID.x, l(1)
% movc r0.x, r0.x, l(0), l(2)
% mov o[r0.x + 0].z, l(0)
% ret

44584243 3429d2d3 fb408d2b 2fd030cc 69cd5a0b 01000000 3c050000 06000000
38000000 b0000000 3c010000 c8010000 a8020000 a0040000 52444546 70000000
00000000 00000000 00000000 3c000000 00055348 00010000 3c000000 52443131
3c000000 18000000 20000000 28000000 24000000 0c000000 00000000 4d696372
6f736f66 74202852 2920484c 534c2053 68616465 7220436f 6d70696c 65722031
302e302e 31303031 312e3136 33383400 4953474e 84000000 04000000 08000000
68000000 00000000 01000000 03000000 00000000 0f0f0000 74000000 00000000
00000000 03000000 01000000 01010000 78000000 00000000 00000000 03000000
01000000 02020000 7e000000 00000000 00000000 03000000 01000000 04040000
53565f50 6f736974 696f6e00 52454400 47524545 4e00424c 554500ab 4f53474e
84000000 04000000 08000000 68000000 00000000 01000000 03000000 00000000
0f000000 74000000 00000000 00000000 03000000 01000000 010e0000 78000000
00000000 00000000 03000000 01000000 020d0000 7e000000 00000000 00000000
03000000 01000000 040b0000 53565f50 6f736974 696f6e00 52454400 47524545
4e00424c 554500ab 50435347 d8000000 07000000 08000000 b0000000 00000000
0d000000 03000000 00000000 010e0000 be000000 00000000 00000000 03000000
00000000 06090000 b0000000 01000000 0d000000 03000000 01000000 010e0000
c0000000 00000000 00000000 03000000 01000000 020d0000 b0000000 02000000
0d000000 03000000 02000000 010e0000 c2000000 00000000 00000000 03000000
02000000 06090000 c4000000 00000000 0e000000 03000000 03000000 010e0000
53565f54 65737346 6163746f 72005800 59005a00 53565f49 6e736964 65546573
73466163 746f7200 53484558 f0010000 50000300 7c000000 71000001 93180001
94180001 95100001 96080001 97180001 6a080001 73000001 99000002 03000000
5f000002 00700100 67000004 12201000 00000000 11000000 67000004 12201000
01000000 12000000 67000004 12201000 02000000 13000000 68000002 01000000
5b000004 12201000 00000000 03000000 36000004 12001000 00000000 0a700100
36000006 12209000 0a001000 00000000 01400000 0000803f 3e000001 73000001
67000004 12201000 03000000 14000000 36000005 12201000 03000000 01400000
0000803f 3e000001 73000001 99000002 03000000 5f000002 00700100 65000003
22201000 00000000 65000003 22201000 01000000 65000003 22201000 02000000
68000002 01000000 5b000004 22201000 00000000 03000000 36000004 12001000
00000000 0a700100 36000006 22209000 0a001000 00000000 01400000 00000000
3e000001 73000001 99000002 02000000 5f000002 00700100 65000003 42201000
00000000 65000003 42201000 02000000 68000002 01000000 5b000004 42201000
00000000 03000000 4f000006 12001000 00000000 0a700100 01400000 01000000
37000009 12001000 00000000 0a001000 00000000 01400000 00000000 01400000
02000000 36000006 42209000 0a001000 00000000 01400000 00000000 3e000001
53544154 94000000 0c000000 01000000 00000000 04000000 00000000 00000000
01000000 04000000 00000000 00000000 00000000 00000000 00000000 00000000
00000000 00000000 00000000 00000000 00000000 06000000 01000000 00000000
00000000 0a000000 00000000 00000000 00000000 00000000 00000000 00000000
03000000 03000000 01000000 02000000 00000000 00000000 00000000

[domain shader]
struct data
{
    float4 position : SV_Position;
    float r : RED;
    float g : GREEN;
    float b : BLUE;
};

struct patch_constant_data
{
    float edges[3] : SV_TessFactor;
    float inside : SV_InsideTessFactor;
    float2 x : X;
    float1 y : Y;
    float2 z : Z;
};

    [domain("tri")]
void main(patch_constant_data input,
        float3 tess_coord : SV_DomainLocation,
        const OutputPatch<data, 3> patch,
        out data output)
{
    output.position = tess_coord.x * patch[0].position
            + tess_coord.y * patch[1].position
            + tess_coord.z * patch[2].position;
    output.r = tess_coord.x * patch[0].r + tess_coord.y * patch[1].r + tess_coord.z * patch[2].r;
    output.g = tess_coord.x * patch[0].g + tess_coord.y * patch[1].g + tess_coord.z * patch[2].g;
    output.b = tess_coord.x * patch[0].b + tess_coord.y * patch[1].b + tess_coord.z * patch[2].b;
}

[test]
if(!llvmpipe) todo(glsl | msl | mvk & vulkan) draw 3 control point patch list 3
if(!llvmpipe) todo(mvk) probe (0, 0, 640, 480) rgba(0.0, 1.0, 0.0, 1.0)
